/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.0.0 (NJsonSchema v10.1.24.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface IFilesClient {
    create(command: CreateFileCommand): Promise<number>;
}

export class FilesClient implements IFilesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateFileCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Files";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }
}

export interface ILeaderboardStatsClient {
    getSeason(seasonId: number, mode: LeaderboardStatsMode | undefined): Promise<PlayerLeaderboardSeasonStatsVm>;
    getAllTime(mode: LeaderboardStatsMode | undefined): Promise<PlayerLeaderboardAllTimeStatsVm>;
}

export class LeaderboardStatsClient implements ILeaderboardStatsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getSeason(seasonId: number, mode: LeaderboardStatsMode | undefined): Promise<PlayerLeaderboardSeasonStatsVm> {
        let url_ = this.baseUrl + "/api/LeaderboardStats/season/{seasonId}/players?";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSeason(_response);
        });
    }

    protected processGetSeason(response: Response): Promise<PlayerLeaderboardSeasonStatsVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerLeaderboardSeasonStatsVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerLeaderboardSeasonStatsVm>(<any>null);
    }

    getAllTime(mode: LeaderboardStatsMode | undefined): Promise<PlayerLeaderboardAllTimeStatsVm> {
        let url_ = this.baseUrl + "/api/LeaderboardStats/players?";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTime(_response);
        });
    }

    protected processGetAllTime(response: Response): Promise<PlayerLeaderboardAllTimeStatsVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerLeaderboardAllTimeStatsVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerLeaderboardAllTimeStatsVm>(<any>null);
    }
}

export interface IMatchesClient {
    get(matchId: number): Promise<MatchSummaryVm>;
}

export class MatchesClient implements IMatchesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(matchId: number): Promise<MatchSummaryVm> {
        let url_ = this.baseUrl + "/api/Matches/{matchId}/summary";
        if (matchId === undefined || matchId === null)
            throw new Error("The parameter 'matchId' must be defined.");
        url_ = url_.replace("{matchId}", encodeURIComponent("" + matchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<MatchSummaryVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchSummaryVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MatchSummaryVm>(<any>null);
    }
}

export interface IPlayersClient {
    get(): Promise<PlayersVm>;
    create(command: CreatePlayerCommand): Promise<number>;
    getPlayerSummaryById(playerId: number): Promise<PlayerSummaryVm>;
    update(playerId: number, command: UpdatePlayerCommand): Promise<FileResponse>;
}

export class PlayersClient implements IPlayersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<PlayersVm> {
        let url_ = this.baseUrl + "/api/Players";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PlayersVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayersVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayersVm>(<any>null);
    }

    create(command: CreatePlayerCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Players";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    getPlayerSummaryById(playerId: number): Promise<PlayerSummaryVm> {
        let url_ = this.baseUrl + "/api/Players/{playerId}/summary";
        if (playerId === undefined || playerId === null)
            throw new Error("The parameter 'playerId' must be defined.");
        url_ = url_.replace("{playerId}", encodeURIComponent("" + playerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlayerSummaryById(_response);
        });
    }

    protected processGetPlayerSummaryById(response: Response): Promise<PlayerSummaryVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlayerSummaryVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlayerSummaryVm>(<any>null);
    }

    update(playerId: number, command: UpdatePlayerCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Players/{playerId}";
        if (playerId === undefined || playerId === null)
            throw new Error("The parameter 'playerId' must be defined.");
        url_ = url_.replace("{playerId}", encodeURIComponent("" + playerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface IRoundsClient {
    get(output: RoundsOutputFileType | null | undefined): Promise<FileResponse>;
}

export class RoundsClient implements IRoundsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(output: RoundsOutputFileType | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Rounds?";
        if (output !== undefined && output !== null)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface ISeasonsClient {
    get(): Promise<SeasonsVm>;
    create(command: CreateSeasonCommand): Promise<number>;
    update(seasonId: number, command: UpdateSeasonCommand): Promise<FileResponse>;
    getSeasonSummaryById(seasonId: number): Promise<SeasonSummaryVm>;
    getSeasonStandingsById(seasonId: number): Promise<SeasonStandingsVm>;
    getSeasonPlayers(seasonId: number): Promise<SeasonPlayersVm>;
}

export class SeasonsClient implements ISeasonsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<SeasonsVm> {
        let url_ = this.baseUrl + "/api/Seasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SeasonsVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeasonsVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeasonsVm>(<any>null);
    }

    create(command: CreateSeasonCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Seasons";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(seasonId: number, command: UpdateSeasonCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Seasons/{seasonId}";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getSeasonSummaryById(seasonId: number): Promise<SeasonSummaryVm> {
        let url_ = this.baseUrl + "/api/Seasons/{seasonId}";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSeasonSummaryById(_response);
        });
    }

    protected processGetSeasonSummaryById(response: Response): Promise<SeasonSummaryVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeasonSummaryVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeasonSummaryVm>(<any>null);
    }

    getSeasonStandingsById(seasonId: number): Promise<SeasonStandingsVm> {
        let url_ = this.baseUrl + "/api/Seasons/{seasonId}/standings";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSeasonStandingsById(_response);
        });
    }

    protected processGetSeasonStandingsById(response: Response): Promise<SeasonStandingsVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeasonStandingsVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeasonStandingsVm>(<any>null);
    }

    getSeasonPlayers(seasonId: number): Promise<SeasonPlayersVm> {
        let url_ = this.baseUrl + "/api/Seasons/{seasonId}/players";
        if (seasonId === undefined || seasonId === null)
            throw new Error("The parameter 'seasonId' must be defined.");
        url_ = url_.replace("{seasonId}", encodeURIComponent("" + seasonId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSeasonPlayers(_response);
        });
    }

    protected processGetSeasonPlayers(response: Response): Promise<SeasonPlayersVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SeasonPlayersVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeasonPlayersVm>(<any>null);
    }
}

export interface ITeamsClient {
    get(teamId: number): Promise<TeamSummaryVm>;
}

export class TeamsClient implements ITeamsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(teamId: number): Promise<TeamSummaryVm> {
        let url_ = this.baseUrl + "/api/Teams/{teamId}/summary";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TeamSummaryVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamSummaryVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TeamSummaryVm>(<any>null);
    }
}

export interface ITodoItemsClient {
    create(command: CreateTodoItemCommand): Promise<number>;
    update(id: number, command: UpdateTodoItemCommand): Promise<FileResponse>;
    delete(id: number): Promise<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Promise<FileResponse>;
}

export class TodoItemsClient implements ITodoItemsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateTodoItemCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    update(id: number, command: UpdateTodoItemCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateItemDetails(_response);
        });
    }

    protected processUpdateItemDetails(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface ITodoListsClient {
    get(): Promise<TodosVm>;
    create(command: CreateTodoListCommand): Promise<number>;
    get2(id: number): Promise<FileResponse>;
    update(id: number, command: UpdateTodoListCommand): Promise<FileResponse>;
    delete(id: number): Promise<FileResponse>;
}

export class TodoListsClient implements ITodoListsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TodosVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodosVm>(<any>null);
    }

    create(command: CreateTodoListCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    get2(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    update(id: number, command: UpdateTodoListCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface IWeatherForecastClient {
    get(): Promise<WeatherForecast[]>;
}

export class WeatherForecastClient implements IWeatherForecastClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherForecast[]>(<any>null);
    }
}

export class CreateFileCommand implements ICreateFileCommand {
    fileName?: string | undefined;
    fileSize?: number;

    constructor(data?: ICreateFileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileSize = _data["fileSize"];
        }
    }

    static fromJS(data: any): CreateFileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileSize"] = this.fileSize;
        return data; 
    }
}

export interface ICreateFileCommand {
    fileName?: string | undefined;
    fileSize?: number;
}

export class PlayerLeaderboardSeasonStatsVm implements IPlayerLeaderboardSeasonStatsVm {
    seasonId?: number;
    seasonName?: string | undefined;
    playerLeaderboardStats?: PlayerLeaderboardStatsDto[] | undefined;

    constructor(data?: IPlayerLeaderboardSeasonStatsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seasonId = _data["seasonId"];
            this.seasonName = _data["seasonName"];
            if (Array.isArray(_data["playerLeaderboardStats"])) {
                this.playerLeaderboardStats = [] as any;
                for (let item of _data["playerLeaderboardStats"])
                    this.playerLeaderboardStats!.push(PlayerLeaderboardStatsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlayerLeaderboardSeasonStatsVm {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerLeaderboardSeasonStatsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seasonId"] = this.seasonId;
        data["seasonName"] = this.seasonName;
        if (Array.isArray(this.playerLeaderboardStats)) {
            data["playerLeaderboardStats"] = [];
            for (let item of this.playerLeaderboardStats)
                data["playerLeaderboardStats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlayerLeaderboardSeasonStatsVm {
    seasonId?: number;
    seasonName?: string | undefined;
    playerLeaderboardStats?: PlayerLeaderboardStatsDto[] | undefined;
}

export class PlayerLeaderboardStatsDto implements IPlayerLeaderboardStatsDto {
    statName?: string | undefined;
    leaderboardStats?: LeaderboardStatsDto[] | undefined;

    constructor(data?: IPlayerLeaderboardStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statName = _data["statName"];
            if (Array.isArray(_data["leaderboardStats"])) {
                this.leaderboardStats = [] as any;
                for (let item of _data["leaderboardStats"])
                    this.leaderboardStats!.push(LeaderboardStatsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlayerLeaderboardStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerLeaderboardStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statName"] = this.statName;
        if (Array.isArray(this.leaderboardStats)) {
            data["leaderboardStats"] = [];
            for (let item of this.leaderboardStats)
                data["leaderboardStats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlayerLeaderboardStatsDto {
    statName?: string | undefined;
    leaderboardStats?: LeaderboardStatsDto[] | undefined;
}

export class LeaderboardStatsDto implements ILeaderboardStatsDto {
    id?: number;
    playerName?: string | undefined;
    stat?: number;

    constructor(data?: ILeaderboardStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.playerName = _data["playerName"];
            this.stat = _data["stat"];
        }
    }

    static fromJS(data: any): LeaderboardStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderboardStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["playerName"] = this.playerName;
        data["stat"] = this.stat;
        return data; 
    }
}

export interface ILeaderboardStatsDto {
    id?: number;
    playerName?: string | undefined;
    stat?: number;
}

export enum LeaderboardStatsMode {
    PerRound = "PerRound",
    Total = "Total",
    Per1Min = "Per1Min",
    Per8Min = "Per8Min",
}

export class PlayerLeaderboardAllTimeStatsVm implements IPlayerLeaderboardAllTimeStatsVm {
    description?: string | undefined;
    playerLeaderboardStats?: PlayerLeaderboardStatsDto[] | undefined;

    constructor(data?: IPlayerLeaderboardAllTimeStatsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["playerLeaderboardStats"])) {
                this.playerLeaderboardStats = [] as any;
                for (let item of _data["playerLeaderboardStats"])
                    this.playerLeaderboardStats!.push(PlayerLeaderboardStatsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlayerLeaderboardAllTimeStatsVm {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerLeaderboardAllTimeStatsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.playerLeaderboardStats)) {
            data["playerLeaderboardStats"] = [];
            for (let item of this.playerLeaderboardStats)
                data["playerLeaderboardStats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlayerLeaderboardAllTimeStatsVm {
    description?: string | undefined;
    playerLeaderboardStats?: PlayerLeaderboardStatsDto[] | undefined;
}

export class MatchSummaryVm implements IMatchSummaryVm {
    matchId?: number;
    seasonId?: number;
    redTeamId?: number;
    blueTeamId?: number;
    roundsPlayed?: number;
    gameTimeTotal?: string;
    seasonName?: string | undefined;
    redTeamName?: string | undefined;
    blueTeamName?: string | undefined;
    mapsPlayed?: MatchMapsPlayedDto[] | undefined;
    lineScore?: MatchLineScoreDto | undefined;
    finalBoxScore?: MatchFinalBoxScoreDto | undefined;
    perRoundBoxScore?: RoundBoxScoreDto[] | undefined;
    demoList?: DemoDto[] | undefined;

    constructor(data?: IMatchSummaryVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchId = _data["matchId"];
            this.seasonId = _data["seasonId"];
            this.redTeamId = _data["redTeamId"];
            this.blueTeamId = _data["blueTeamId"];
            this.roundsPlayed = _data["roundsPlayed"];
            this.gameTimeTotal = _data["gameTimeTotal"];
            this.seasonName = _data["seasonName"];
            this.redTeamName = _data["redTeamName"];
            this.blueTeamName = _data["blueTeamName"];
            if (Array.isArray(_data["mapsPlayed"])) {
                this.mapsPlayed = [] as any;
                for (let item of _data["mapsPlayed"])
                    this.mapsPlayed!.push(MatchMapsPlayedDto.fromJS(item));
            }
            this.lineScore = _data["lineScore"] ? MatchLineScoreDto.fromJS(_data["lineScore"]) : <any>undefined;
            this.finalBoxScore = _data["finalBoxScore"] ? MatchFinalBoxScoreDto.fromJS(_data["finalBoxScore"]) : <any>undefined;
            if (Array.isArray(_data["perRoundBoxScore"])) {
                this.perRoundBoxScore = [] as any;
                for (let item of _data["perRoundBoxScore"])
                    this.perRoundBoxScore!.push(RoundBoxScoreDto.fromJS(item));
            }
            if (Array.isArray(_data["demoList"])) {
                this.demoList = [] as any;
                for (let item of _data["demoList"])
                    this.demoList!.push(DemoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MatchSummaryVm {
        data = typeof data === 'object' ? data : {};
        let result = new MatchSummaryVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchId"] = this.matchId;
        data["seasonId"] = this.seasonId;
        data["redTeamId"] = this.redTeamId;
        data["blueTeamId"] = this.blueTeamId;
        data["roundsPlayed"] = this.roundsPlayed;
        data["gameTimeTotal"] = this.gameTimeTotal;
        data["seasonName"] = this.seasonName;
        data["redTeamName"] = this.redTeamName;
        data["blueTeamName"] = this.blueTeamName;
        if (Array.isArray(this.mapsPlayed)) {
            data["mapsPlayed"] = [];
            for (let item of this.mapsPlayed)
                data["mapsPlayed"].push(item.toJSON());
        }
        data["lineScore"] = this.lineScore ? this.lineScore.toJSON() : <any>undefined;
        data["finalBoxScore"] = this.finalBoxScore ? this.finalBoxScore.toJSON() : <any>undefined;
        if (Array.isArray(this.perRoundBoxScore)) {
            data["perRoundBoxScore"] = [];
            for (let item of this.perRoundBoxScore)
                data["perRoundBoxScore"].push(item.toJSON());
        }
        if (Array.isArray(this.demoList)) {
            data["demoList"] = [];
            for (let item of this.demoList)
                data["demoList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMatchSummaryVm {
    matchId?: number;
    seasonId?: number;
    redTeamId?: number;
    blueTeamId?: number;
    roundsPlayed?: number;
    gameTimeTotal?: string;
    seasonName?: string | undefined;
    redTeamName?: string | undefined;
    blueTeamName?: string | undefined;
    mapsPlayed?: MatchMapsPlayedDto[] | undefined;
    lineScore?: MatchLineScoreDto | undefined;
    finalBoxScore?: MatchFinalBoxScoreDto | undefined;
    perRoundBoxScore?: RoundBoxScoreDto[] | undefined;
    demoList?: DemoDto[] | undefined;
}

export class MatchMapsPlayedDto implements IMatchMapsPlayedDto {
    mapId?: number;
    mapNumber?: number;
    mapName?: string | undefined;
    mapPack?: string | undefined;

    constructor(data?: IMatchMapsPlayedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mapId = _data["mapId"];
            this.mapNumber = _data["mapNumber"];
            this.mapName = _data["mapName"];
            this.mapPack = _data["mapPack"];
        }
    }

    static fromJS(data: any): MatchMapsPlayedDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchMapsPlayedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mapId"] = this.mapId;
        data["mapNumber"] = this.mapNumber;
        data["mapName"] = this.mapName;
        data["mapPack"] = this.mapPack;
        return data; 
    }
}

export interface IMatchMapsPlayedDto {
    mapId?: number;
    mapNumber?: number;
    mapName?: string | undefined;
    mapPack?: string | undefined;
}

export class MatchLineScoreDto implements IMatchLineScoreDto {
    redTeamName?: string | undefined;
    blueTeamName?: string | undefined;
    roundScore?: ScoreDto[] | undefined;
    matchResult?: MatchResultDto | undefined;

    constructor(data?: IMatchLineScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.redTeamName = _data["redTeamName"];
            this.blueTeamName = _data["blueTeamName"];
            if (Array.isArray(_data["roundScore"])) {
                this.roundScore = [] as any;
                for (let item of _data["roundScore"])
                    this.roundScore!.push(ScoreDto.fromJS(item));
            }
            this.matchResult = _data["matchResult"] ? MatchResultDto.fromJS(_data["matchResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MatchLineScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchLineScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redTeamName"] = this.redTeamName;
        data["blueTeamName"] = this.blueTeamName;
        if (Array.isArray(this.roundScore)) {
            data["roundScore"] = [];
            for (let item of this.roundScore)
                data["roundScore"].push(item.toJSON());
        }
        data["matchResult"] = this.matchResult ? this.matchResult.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMatchLineScoreDto {
    redTeamName?: string | undefined;
    blueTeamName?: string | undefined;
    roundScore?: ScoreDto[] | undefined;
    matchResult?: MatchResultDto | undefined;
}

export class ScoreDto implements IScoreDto {
    round?: string | undefined;
    redScore?: number;
    blueScore?: number;
    roundWinner?: string | undefined;

    constructor(data?: IScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.round = _data["round"];
            this.redScore = _data["redScore"];
            this.blueScore = _data["blueScore"];
            this.roundWinner = _data["roundWinner"];
        }
    }

    static fromJS(data: any): ScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["round"] = this.round;
        data["redScore"] = this.redScore;
        data["blueScore"] = this.blueScore;
        data["roundWinner"] = this.roundWinner;
        return data; 
    }
}

export interface IScoreDto {
    round?: string | undefined;
    redScore?: number;
    blueScore?: number;
    roundWinner?: string | undefined;
}

export class MatchResultDto implements IMatchResultDto {
    redRoundScore?: number;
    blueRoundScore?: number;
    gameWinner?: string | undefined;

    constructor(data?: IMatchResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.redRoundScore = _data["redRoundScore"];
            this.blueRoundScore = _data["blueRoundScore"];
            this.gameWinner = _data["gameWinner"];
        }
    }

    static fromJS(data: any): MatchResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redRoundScore"] = this.redRoundScore;
        data["blueRoundScore"] = this.blueRoundScore;
        data["gameWinner"] = this.gameWinner;
        return data; 
    }
}

export interface IMatchResultDto {
    redRoundScore?: number;
    blueRoundScore?: number;
    gameWinner?: string | undefined;
}

export class MatchFinalBoxScoreDto implements IMatchFinalBoxScoreDto {
    redTeamFinalBoxScore?: MatchStatsDto | undefined;
    blueTeamFinalBoxScore?: MatchStatsDto | undefined;
    redTeamPlayerFinalBoxScore?: GamePlayersDto[] | undefined;
    blueTeamPlayerFinalBoxScore?: GamePlayersDto[] | undefined;

    constructor(data?: IMatchFinalBoxScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.redTeamFinalBoxScore = _data["redTeamFinalBoxScore"] ? MatchStatsDto.fromJS(_data["redTeamFinalBoxScore"]) : <any>undefined;
            this.blueTeamFinalBoxScore = _data["blueTeamFinalBoxScore"] ? MatchStatsDto.fromJS(_data["blueTeamFinalBoxScore"]) : <any>undefined;
            if (Array.isArray(_data["redTeamPlayerFinalBoxScore"])) {
                this.redTeamPlayerFinalBoxScore = [] as any;
                for (let item of _data["redTeamPlayerFinalBoxScore"])
                    this.redTeamPlayerFinalBoxScore!.push(GamePlayersDto.fromJS(item));
            }
            if (Array.isArray(_data["blueTeamPlayerFinalBoxScore"])) {
                this.blueTeamPlayerFinalBoxScore = [] as any;
                for (let item of _data["blueTeamPlayerFinalBoxScore"])
                    this.blueTeamPlayerFinalBoxScore!.push(GamePlayersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MatchFinalBoxScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchFinalBoxScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redTeamFinalBoxScore"] = this.redTeamFinalBoxScore ? this.redTeamFinalBoxScore.toJSON() : <any>undefined;
        data["blueTeamFinalBoxScore"] = this.blueTeamFinalBoxScore ? this.blueTeamFinalBoxScore.toJSON() : <any>undefined;
        if (Array.isArray(this.redTeamPlayerFinalBoxScore)) {
            data["redTeamPlayerFinalBoxScore"] = [];
            for (let item of this.redTeamPlayerFinalBoxScore)
                data["redTeamPlayerFinalBoxScore"].push(item.toJSON());
        }
        if (Array.isArray(this.blueTeamPlayerFinalBoxScore)) {
            data["blueTeamPlayerFinalBoxScore"] = [];
            for (let item of this.blueTeamPlayerFinalBoxScore)
                data["blueTeamPlayerFinalBoxScore"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMatchFinalBoxScoreDto {
    redTeamFinalBoxScore?: MatchStatsDto | undefined;
    blueTeamFinalBoxScore?: MatchStatsDto | undefined;
    redTeamPlayerFinalBoxScore?: GamePlayersDto[] | undefined;
    blueTeamPlayerFinalBoxScore?: GamePlayersDto[] | undefined;
}

export class MatchStatsDto implements IMatchStatsDto {
    timePlayed?: string;
    captures?: number;
    pickupCaptures?: number;
    assists?: number;
    damageBetweenTouchAndCaptureMax?: number | undefined;
    damageBetweenTouchAndCaptureAverage?: number | undefined;
    captureTimeMin?: string;
    captureTimeMax?: string;
    captureTimeAverage?: string;
    captureHealthMin?: number | undefined;
    captureHealthMax?: number | undefined;
    captureHealthAverage?: number | undefined;
    captureGreenArmorMin?: number | undefined;
    captureGreenArmorMax?: number | undefined;
    captureGreenArmorAverage?: number | undefined;
    captureBlueArmorMin?: number | undefined;
    captureBlueArmorMax?: number | undefined;
    captureBlueArmorAverage?: number | undefined;
    capturesWithSuperPickups?: number;
    flagCarriersKilledWhileHoldingFlag?: number;
    highestKillsBeforeCapturing?: number;
    pickupCaptureTimeMin?: string;
    pickupCaptureTimeMax?: string;
    pickupCaptureTimeAverage?: string;
    flagTouches?: number;
    pickupFlagTouches?: number;
    flagDefenses?: number;
    flagReturns?: number;
    frags?: number;
    deaths?: number;
    environmentalDeaths?: number;
    environmentalFlagCarrierDeaths?: number;
    teamKills?: number;
    killingSprees?: number;
    rampages?: number;
    dominatings?: number;
    unstoppables?: number;
    godLikes?: number;
    wickedSicks?: number;
    longestSpree?: number;
    doubleKills?: number;
    multiKills?: number;
    ultraKills?: number;
    monsterKills?: number;
    highestMultiKill?: number;
    pickupHealthGained?: number;
    healthFromNonPowerups?: number;
    healthWhenTouchingFlagMin?: number | undefined;
    healthWhenTouchingFlagMax?: number | undefined;
    healthWhenTouchingFlagAverage?: number | undefined;
    greenArmorWhenTouchingFlagMin?: number | undefined;
    greenArmorWhenTouchingFlagMax?: number | undefined;
    greenArmorWhenTouchingFlagAverage?: number | undefined;
    blueArmorWhenTouchingFlagMin?: number | undefined;
    blueArmorWhenTouchingFlagMax?: number | undefined;
    blueArmorWhenTouchingFlagAverage?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureMin?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureMax?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureAverage?: number | undefined;
    damage?: number;
    damageTakenFromEnvironment?: number;
    damageTakenFromEnvironmentAsFlagCarrier?: number;
    damageToFlagCarriers?: number;
    damageDoneWithFlag?: number;
    damageToGreenArmor?: number;
    damageToBlueArmor?: number;
    powerups?: number;

    constructor(data?: IMatchStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timePlayed = _data["timePlayed"];
            this.captures = _data["captures"];
            this.pickupCaptures = _data["pickupCaptures"];
            this.assists = _data["assists"];
            this.damageBetweenTouchAndCaptureMax = _data["damageBetweenTouchAndCaptureMax"];
            this.damageBetweenTouchAndCaptureAverage = _data["damageBetweenTouchAndCaptureAverage"];
            this.captureTimeMin = _data["captureTimeMin"];
            this.captureTimeMax = _data["captureTimeMax"];
            this.captureTimeAverage = _data["captureTimeAverage"];
            this.captureHealthMin = _data["captureHealthMin"];
            this.captureHealthMax = _data["captureHealthMax"];
            this.captureHealthAverage = _data["captureHealthAverage"];
            this.captureGreenArmorMin = _data["captureGreenArmorMin"];
            this.captureGreenArmorMax = _data["captureGreenArmorMax"];
            this.captureGreenArmorAverage = _data["captureGreenArmorAverage"];
            this.captureBlueArmorMin = _data["captureBlueArmorMin"];
            this.captureBlueArmorMax = _data["captureBlueArmorMax"];
            this.captureBlueArmorAverage = _data["captureBlueArmorAverage"];
            this.capturesWithSuperPickups = _data["capturesWithSuperPickups"];
            this.flagCarriersKilledWhileHoldingFlag = _data["flagCarriersKilledWhileHoldingFlag"];
            this.highestKillsBeforeCapturing = _data["highestKillsBeforeCapturing"];
            this.pickupCaptureTimeMin = _data["pickupCaptureTimeMin"];
            this.pickupCaptureTimeMax = _data["pickupCaptureTimeMax"];
            this.pickupCaptureTimeAverage = _data["pickupCaptureTimeAverage"];
            this.flagTouches = _data["flagTouches"];
            this.pickupFlagTouches = _data["pickupFlagTouches"];
            this.flagDefenses = _data["flagDefenses"];
            this.flagReturns = _data["flagReturns"];
            this.frags = _data["frags"];
            this.deaths = _data["deaths"];
            this.environmentalDeaths = _data["environmentalDeaths"];
            this.environmentalFlagCarrierDeaths = _data["environmentalFlagCarrierDeaths"];
            this.teamKills = _data["teamKills"];
            this.killingSprees = _data["killingSprees"];
            this.rampages = _data["rampages"];
            this.dominatings = _data["dominatings"];
            this.unstoppables = _data["unstoppables"];
            this.godLikes = _data["godLikes"];
            this.wickedSicks = _data["wickedSicks"];
            this.longestSpree = _data["longestSpree"];
            this.doubleKills = _data["doubleKills"];
            this.multiKills = _data["multiKills"];
            this.ultraKills = _data["ultraKills"];
            this.monsterKills = _data["monsterKills"];
            this.highestMultiKill = _data["highestMultiKill"];
            this.pickupHealthGained = _data["pickupHealthGained"];
            this.healthFromNonPowerups = _data["healthFromNonPowerups"];
            this.healthWhenTouchingFlagMin = _data["healthWhenTouchingFlagMin"];
            this.healthWhenTouchingFlagMax = _data["healthWhenTouchingFlagMax"];
            this.healthWhenTouchingFlagAverage = _data["healthWhenTouchingFlagAverage"];
            this.greenArmorWhenTouchingFlagMin = _data["greenArmorWhenTouchingFlagMin"];
            this.greenArmorWhenTouchingFlagMax = _data["greenArmorWhenTouchingFlagMax"];
            this.greenArmorWhenTouchingFlagAverage = _data["greenArmorWhenTouchingFlagAverage"];
            this.blueArmorWhenTouchingFlagMin = _data["blueArmorWhenTouchingFlagMin"];
            this.blueArmorWhenTouchingFlagMax = _data["blueArmorWhenTouchingFlagMax"];
            this.blueArmorWhenTouchingFlagAverage = _data["blueArmorWhenTouchingFlagAverage"];
            this.healthWhenTouchingFlagThatResultsInCaptureMin = _data["healthWhenTouchingFlagThatResultsInCaptureMin"];
            this.healthWhenTouchingFlagThatResultsInCaptureMax = _data["healthWhenTouchingFlagThatResultsInCaptureMax"];
            this.healthWhenTouchingFlagThatResultsInCaptureAverage = _data["healthWhenTouchingFlagThatResultsInCaptureAverage"];
            this.damage = _data["damage"];
            this.damageTakenFromEnvironment = _data["damageTakenFromEnvironment"];
            this.damageTakenFromEnvironmentAsFlagCarrier = _data["damageTakenFromEnvironmentAsFlagCarrier"];
            this.damageToFlagCarriers = _data["damageToFlagCarriers"];
            this.damageDoneWithFlag = _data["damageDoneWithFlag"];
            this.damageToGreenArmor = _data["damageToGreenArmor"];
            this.damageToBlueArmor = _data["damageToBlueArmor"];
            this.powerups = _data["powerups"];
        }
    }

    static fromJS(data: any): MatchStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timePlayed"] = this.timePlayed;
        data["captures"] = this.captures;
        data["pickupCaptures"] = this.pickupCaptures;
        data["assists"] = this.assists;
        data["damageBetweenTouchAndCaptureMax"] = this.damageBetweenTouchAndCaptureMax;
        data["damageBetweenTouchAndCaptureAverage"] = this.damageBetweenTouchAndCaptureAverage;
        data["captureTimeMin"] = this.captureTimeMin;
        data["captureTimeMax"] = this.captureTimeMax;
        data["captureTimeAverage"] = this.captureTimeAverage;
        data["captureHealthMin"] = this.captureHealthMin;
        data["captureHealthMax"] = this.captureHealthMax;
        data["captureHealthAverage"] = this.captureHealthAverage;
        data["captureGreenArmorMin"] = this.captureGreenArmorMin;
        data["captureGreenArmorMax"] = this.captureGreenArmorMax;
        data["captureGreenArmorAverage"] = this.captureGreenArmorAverage;
        data["captureBlueArmorMin"] = this.captureBlueArmorMin;
        data["captureBlueArmorMax"] = this.captureBlueArmorMax;
        data["captureBlueArmorAverage"] = this.captureBlueArmorAverage;
        data["capturesWithSuperPickups"] = this.capturesWithSuperPickups;
        data["flagCarriersKilledWhileHoldingFlag"] = this.flagCarriersKilledWhileHoldingFlag;
        data["highestKillsBeforeCapturing"] = this.highestKillsBeforeCapturing;
        data["pickupCaptureTimeMin"] = this.pickupCaptureTimeMin;
        data["pickupCaptureTimeMax"] = this.pickupCaptureTimeMax;
        data["pickupCaptureTimeAverage"] = this.pickupCaptureTimeAverage;
        data["flagTouches"] = this.flagTouches;
        data["pickupFlagTouches"] = this.pickupFlagTouches;
        data["flagDefenses"] = this.flagDefenses;
        data["flagReturns"] = this.flagReturns;
        data["frags"] = this.frags;
        data["deaths"] = this.deaths;
        data["environmentalDeaths"] = this.environmentalDeaths;
        data["environmentalFlagCarrierDeaths"] = this.environmentalFlagCarrierDeaths;
        data["teamKills"] = this.teamKills;
        data["killingSprees"] = this.killingSprees;
        data["rampages"] = this.rampages;
        data["dominatings"] = this.dominatings;
        data["unstoppables"] = this.unstoppables;
        data["godLikes"] = this.godLikes;
        data["wickedSicks"] = this.wickedSicks;
        data["longestSpree"] = this.longestSpree;
        data["doubleKills"] = this.doubleKills;
        data["multiKills"] = this.multiKills;
        data["ultraKills"] = this.ultraKills;
        data["monsterKills"] = this.monsterKills;
        data["highestMultiKill"] = this.highestMultiKill;
        data["pickupHealthGained"] = this.pickupHealthGained;
        data["healthFromNonPowerups"] = this.healthFromNonPowerups;
        data["healthWhenTouchingFlagMin"] = this.healthWhenTouchingFlagMin;
        data["healthWhenTouchingFlagMax"] = this.healthWhenTouchingFlagMax;
        data["healthWhenTouchingFlagAverage"] = this.healthWhenTouchingFlagAverage;
        data["greenArmorWhenTouchingFlagMin"] = this.greenArmorWhenTouchingFlagMin;
        data["greenArmorWhenTouchingFlagMax"] = this.greenArmorWhenTouchingFlagMax;
        data["greenArmorWhenTouchingFlagAverage"] = this.greenArmorWhenTouchingFlagAverage;
        data["blueArmorWhenTouchingFlagMin"] = this.blueArmorWhenTouchingFlagMin;
        data["blueArmorWhenTouchingFlagMax"] = this.blueArmorWhenTouchingFlagMax;
        data["blueArmorWhenTouchingFlagAverage"] = this.blueArmorWhenTouchingFlagAverage;
        data["healthWhenTouchingFlagThatResultsInCaptureMin"] = this.healthWhenTouchingFlagThatResultsInCaptureMin;
        data["healthWhenTouchingFlagThatResultsInCaptureMax"] = this.healthWhenTouchingFlagThatResultsInCaptureMax;
        data["healthWhenTouchingFlagThatResultsInCaptureAverage"] = this.healthWhenTouchingFlagThatResultsInCaptureAverage;
        data["damage"] = this.damage;
        data["damageTakenFromEnvironment"] = this.damageTakenFromEnvironment;
        data["damageTakenFromEnvironmentAsFlagCarrier"] = this.damageTakenFromEnvironmentAsFlagCarrier;
        data["damageToFlagCarriers"] = this.damageToFlagCarriers;
        data["damageDoneWithFlag"] = this.damageDoneWithFlag;
        data["damageToGreenArmor"] = this.damageToGreenArmor;
        data["damageToBlueArmor"] = this.damageToBlueArmor;
        data["powerups"] = this.powerups;
        return data; 
    }
}

export interface IMatchStatsDto {
    timePlayed?: string;
    captures?: number;
    pickupCaptures?: number;
    assists?: number;
    damageBetweenTouchAndCaptureMax?: number | undefined;
    damageBetweenTouchAndCaptureAverage?: number | undefined;
    captureTimeMin?: string;
    captureTimeMax?: string;
    captureTimeAverage?: string;
    captureHealthMin?: number | undefined;
    captureHealthMax?: number | undefined;
    captureHealthAverage?: number | undefined;
    captureGreenArmorMin?: number | undefined;
    captureGreenArmorMax?: number | undefined;
    captureGreenArmorAverage?: number | undefined;
    captureBlueArmorMin?: number | undefined;
    captureBlueArmorMax?: number | undefined;
    captureBlueArmorAverage?: number | undefined;
    capturesWithSuperPickups?: number;
    flagCarriersKilledWhileHoldingFlag?: number;
    highestKillsBeforeCapturing?: number;
    pickupCaptureTimeMin?: string;
    pickupCaptureTimeMax?: string;
    pickupCaptureTimeAverage?: string;
    flagTouches?: number;
    pickupFlagTouches?: number;
    flagDefenses?: number;
    flagReturns?: number;
    frags?: number;
    deaths?: number;
    environmentalDeaths?: number;
    environmentalFlagCarrierDeaths?: number;
    teamKills?: number;
    killingSprees?: number;
    rampages?: number;
    dominatings?: number;
    unstoppables?: number;
    godLikes?: number;
    wickedSicks?: number;
    longestSpree?: number;
    doubleKills?: number;
    multiKills?: number;
    ultraKills?: number;
    monsterKills?: number;
    highestMultiKill?: number;
    pickupHealthGained?: number;
    healthFromNonPowerups?: number;
    healthWhenTouchingFlagMin?: number | undefined;
    healthWhenTouchingFlagMax?: number | undefined;
    healthWhenTouchingFlagAverage?: number | undefined;
    greenArmorWhenTouchingFlagMin?: number | undefined;
    greenArmorWhenTouchingFlagMax?: number | undefined;
    greenArmorWhenTouchingFlagAverage?: number | undefined;
    blueArmorWhenTouchingFlagMin?: number | undefined;
    blueArmorWhenTouchingFlagMax?: number | undefined;
    blueArmorWhenTouchingFlagAverage?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureMin?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureMax?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureAverage?: number | undefined;
    damage?: number;
    damageTakenFromEnvironment?: number;
    damageTakenFromEnvironmentAsFlagCarrier?: number;
    damageToFlagCarriers?: number;
    damageDoneWithFlag?: number;
    damageToGreenArmor?: number;
    damageToBlueArmor?: number;
    powerups?: number;
}

export class GamePlayersDto implements IGamePlayersDto {
    playerId?: number;
    playerName?: string | undefined;
    matchStats?: MatchStatsDto | undefined;

    constructor(data?: IGamePlayersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.playerName = _data["playerName"];
            this.matchStats = _data["matchStats"] ? MatchStatsDto.fromJS(_data["matchStats"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GamePlayersDto {
        data = typeof data === 'object' ? data : {};
        let result = new GamePlayersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["playerName"] = this.playerName;
        data["matchStats"] = this.matchStats ? this.matchStats.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGamePlayersDto {
    playerId?: number;
    playerName?: string | undefined;
    matchStats?: MatchStatsDto | undefined;
}

export class RoundBoxScoreDto implements IRoundBoxScoreDto {
    roundNumber?: number;
    roundTimeTotal?: string;
    redTeamBoxScore?: MatchStatsDto | undefined;
    blueTeamBoxScore?: MatchStatsDto | undefined;
    redTeamPlayerRoundBoxScore?: GamePlayersDto[] | undefined;
    blueTeamPlayerRoundBoxScore?: GamePlayersDto[] | undefined;

    constructor(data?: IRoundBoxScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roundNumber = _data["roundNumber"];
            this.roundTimeTotal = _data["roundTimeTotal"];
            this.redTeamBoxScore = _data["redTeamBoxScore"] ? MatchStatsDto.fromJS(_data["redTeamBoxScore"]) : <any>undefined;
            this.blueTeamBoxScore = _data["blueTeamBoxScore"] ? MatchStatsDto.fromJS(_data["blueTeamBoxScore"]) : <any>undefined;
            if (Array.isArray(_data["redTeamPlayerRoundBoxScore"])) {
                this.redTeamPlayerRoundBoxScore = [] as any;
                for (let item of _data["redTeamPlayerRoundBoxScore"])
                    this.redTeamPlayerRoundBoxScore!.push(GamePlayersDto.fromJS(item));
            }
            if (Array.isArray(_data["blueTeamPlayerRoundBoxScore"])) {
                this.blueTeamPlayerRoundBoxScore = [] as any;
                for (let item of _data["blueTeamPlayerRoundBoxScore"])
                    this.blueTeamPlayerRoundBoxScore!.push(GamePlayersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoundBoxScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoundBoxScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roundNumber"] = this.roundNumber;
        data["roundTimeTotal"] = this.roundTimeTotal;
        data["redTeamBoxScore"] = this.redTeamBoxScore ? this.redTeamBoxScore.toJSON() : <any>undefined;
        data["blueTeamBoxScore"] = this.blueTeamBoxScore ? this.blueTeamBoxScore.toJSON() : <any>undefined;
        if (Array.isArray(this.redTeamPlayerRoundBoxScore)) {
            data["redTeamPlayerRoundBoxScore"] = [];
            for (let item of this.redTeamPlayerRoundBoxScore)
                data["redTeamPlayerRoundBoxScore"].push(item.toJSON());
        }
        if (Array.isArray(this.blueTeamPlayerRoundBoxScore)) {
            data["blueTeamPlayerRoundBoxScore"] = [];
            for (let item of this.blueTeamPlayerRoundBoxScore)
                data["blueTeamPlayerRoundBoxScore"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoundBoxScoreDto {
    roundNumber?: number;
    roundTimeTotal?: string;
    redTeamBoxScore?: MatchStatsDto | undefined;
    blueTeamBoxScore?: MatchStatsDto | undefined;
    redTeamPlayerRoundBoxScore?: GamePlayersDto[] | undefined;
    blueTeamPlayerRoundBoxScore?: GamePlayersDto[] | undefined;
}

export class DemoDto implements IDemoDto {
    playerId?: number;
    playerName?: string | undefined;
    demoLost?: boolean;
    demoFilePath?: string | undefined;

    constructor(data?: IDemoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.playerName = _data["playerName"];
            this.demoLost = _data["demoLost"];
            this.demoFilePath = _data["demoFilePath"];
        }
    }

    static fromJS(data: any): DemoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DemoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["playerName"] = this.playerName;
        data["demoLost"] = this.demoLost;
        data["demoFilePath"] = this.demoFilePath;
        return data; 
    }
}

export interface IDemoDto {
    playerId?: number;
    playerName?: string | undefined;
    demoLost?: boolean;
    demoFilePath?: string | undefined;
}

export class PlayersVm implements IPlayersVm {
    playerList?: PlayerDto[] | undefined;

    constructor(data?: IPlayersVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["playerList"])) {
                this.playerList = [] as any;
                for (let item of _data["playerList"])
                    this.playerList!.push(PlayerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlayersVm {
        data = typeof data === 'object' ? data : {};
        let result = new PlayersVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.playerList)) {
            data["playerList"] = [];
            for (let item of this.playerList)
                data["playerList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlayersVm {
    playerList?: PlayerDto[] | undefined;
}

export class PlayerDto implements IPlayerDto {
    id?: number;
    playerName?: string | undefined;

    constructor(data?: IPlayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.playerName = _data["playerName"];
        }
    }

    static fromJS(data: any): PlayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["playerName"] = this.playerName;
        return data; 
    }
}

export interface IPlayerDto {
    id?: number;
    playerName?: string | undefined;
}

export class PlayerSummaryVm implements IPlayerSummaryVm {
    id?: number;
    name?: string | undefined;
    seasonsPlayedIn?: SeasonsPlayedInDto[] | undefined;
    playerAllTimeStats?: StatsDto | undefined;
    totalRecord?: PlayerCaptainRecordDto | undefined;
    regularSeasonRecord?: PlayerCaptainRecordDto | undefined;
    playoffRecord?: PlayerCaptainRecordDto | undefined;
    finalsRecord?: PlayerCaptainRecordDto | undefined;
    seasonStats?: SeasonPlayerStatsDto[] | undefined;

    constructor(data?: IPlayerSummaryVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["seasonsPlayedIn"])) {
                this.seasonsPlayedIn = [] as any;
                for (let item of _data["seasonsPlayedIn"])
                    this.seasonsPlayedIn!.push(SeasonsPlayedInDto.fromJS(item));
            }
            this.playerAllTimeStats = _data["playerAllTimeStats"] ? StatsDto.fromJS(_data["playerAllTimeStats"]) : <any>undefined;
            this.totalRecord = _data["totalRecord"] ? PlayerCaptainRecordDto.fromJS(_data["totalRecord"]) : <any>undefined;
            this.regularSeasonRecord = _data["regularSeasonRecord"] ? PlayerCaptainRecordDto.fromJS(_data["regularSeasonRecord"]) : <any>undefined;
            this.playoffRecord = _data["playoffRecord"] ? PlayerCaptainRecordDto.fromJS(_data["playoffRecord"]) : <any>undefined;
            this.finalsRecord = _data["finalsRecord"] ? PlayerCaptainRecordDto.fromJS(_data["finalsRecord"]) : <any>undefined;
            if (Array.isArray(_data["seasonStats"])) {
                this.seasonStats = [] as any;
                for (let item of _data["seasonStats"])
                    this.seasonStats!.push(SeasonPlayerStatsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlayerSummaryVm {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerSummaryVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.seasonsPlayedIn)) {
            data["seasonsPlayedIn"] = [];
            for (let item of this.seasonsPlayedIn)
                data["seasonsPlayedIn"].push(item.toJSON());
        }
        data["playerAllTimeStats"] = this.playerAllTimeStats ? this.playerAllTimeStats.toJSON() : <any>undefined;
        data["totalRecord"] = this.totalRecord ? this.totalRecord.toJSON() : <any>undefined;
        data["regularSeasonRecord"] = this.regularSeasonRecord ? this.regularSeasonRecord.toJSON() : <any>undefined;
        data["playoffRecord"] = this.playoffRecord ? this.playoffRecord.toJSON() : <any>undefined;
        data["finalsRecord"] = this.finalsRecord ? this.finalsRecord.toJSON() : <any>undefined;
        if (Array.isArray(this.seasonStats)) {
            data["seasonStats"] = [];
            for (let item of this.seasonStats)
                data["seasonStats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlayerSummaryVm {
    id?: number;
    name?: string | undefined;
    seasonsPlayedIn?: SeasonsPlayedInDto[] | undefined;
    playerAllTimeStats?: StatsDto | undefined;
    totalRecord?: PlayerCaptainRecordDto | undefined;
    regularSeasonRecord?: PlayerCaptainRecordDto | undefined;
    playoffRecord?: PlayerCaptainRecordDto | undefined;
    finalsRecord?: PlayerCaptainRecordDto | undefined;
    seasonStats?: SeasonPlayerStatsDto[] | undefined;
}

export class SeasonsPlayedInDto implements ISeasonsPlayedInDto {
    id?: number;
    seasonName?: string | undefined;
    teamsPlayedFor?: TeamsPlayedForDto[] | undefined;

    constructor(data?: ISeasonsPlayedInDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.seasonName = _data["seasonName"];
            if (Array.isArray(_data["teamsPlayedFor"])) {
                this.teamsPlayedFor = [] as any;
                for (let item of _data["teamsPlayedFor"])
                    this.teamsPlayedFor!.push(TeamsPlayedForDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SeasonsPlayedInDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonsPlayedInDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["seasonName"] = this.seasonName;
        if (Array.isArray(this.teamsPlayedFor)) {
            data["teamsPlayedFor"] = [];
            for (let item of this.teamsPlayedFor)
                data["teamsPlayedFor"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISeasonsPlayedInDto {
    id?: number;
    seasonName?: string | undefined;
    teamsPlayedFor?: TeamsPlayedForDto[] | undefined;
}

export class TeamsPlayedForDto implements ITeamsPlayedForDto {
    id?: number;
    teamName?: string | undefined;
    draftPosition?: string | undefined;
    didTeamWinSeason?: boolean;

    constructor(data?: ITeamsPlayedForDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.teamName = _data["teamName"];
            this.draftPosition = _data["draftPosition"];
            this.didTeamWinSeason = _data["didTeamWinSeason"];
        }
    }

    static fromJS(data: any): TeamsPlayedForDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamsPlayedForDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["teamName"] = this.teamName;
        data["draftPosition"] = this.draftPosition;
        data["didTeamWinSeason"] = this.didTeamWinSeason;
        return data; 
    }
}

export interface ITeamsPlayedForDto {
    id?: number;
    teamName?: string | undefined;
    draftPosition?: string | undefined;
    didTeamWinSeason?: boolean;
}

export class StatsDto implements IStatsDto {
    roundsPlayed?: number;
    totalTimePlayed?: string;
    totalFrags?: number;
    frags?: number;
    flagCarrierFrags?: number;
    deaths?: number;
    environmentalDeaths?: number;
    damage?: number;
    flagCarrierDamage?: number;
    damageWithFlag?: number;
    flagTouches?: number;
    pickupFlagTouches?: number;
    assists?: number;
    captures?: number;
    pickupCaptures?: number;
    flagReturns?: number;
    powerPickups?: number;
    killingSprees?: number;
    rampages?: number;
    dominations?: number;
    unstoppables?: number;
    godLikes?: number;
    wickedSicks?: number;
    doubleKills?: number;
    multiKills?: number;
    ultraKills?: number;
    monsterKills?: number;

    constructor(data?: IStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roundsPlayed = _data["roundsPlayed"];
            this.totalTimePlayed = _data["totalTimePlayed"];
            this.totalFrags = _data["totalFrags"];
            this.frags = _data["frags"];
            this.flagCarrierFrags = _data["flagCarrierFrags"];
            this.deaths = _data["deaths"];
            this.environmentalDeaths = _data["environmentalDeaths"];
            this.damage = _data["damage"];
            this.flagCarrierDamage = _data["flagCarrierDamage"];
            this.damageWithFlag = _data["damageWithFlag"];
            this.flagTouches = _data["flagTouches"];
            this.pickupFlagTouches = _data["pickupFlagTouches"];
            this.assists = _data["assists"];
            this.captures = _data["captures"];
            this.pickupCaptures = _data["pickupCaptures"];
            this.flagReturns = _data["flagReturns"];
            this.powerPickups = _data["powerPickups"];
            this.killingSprees = _data["killingSprees"];
            this.rampages = _data["rampages"];
            this.dominations = _data["dominations"];
            this.unstoppables = _data["unstoppables"];
            this.godLikes = _data["godLikes"];
            this.wickedSicks = _data["wickedSicks"];
            this.doubleKills = _data["doubleKills"];
            this.multiKills = _data["multiKills"];
            this.ultraKills = _data["ultraKills"];
            this.monsterKills = _data["monsterKills"];
        }
    }

    static fromJS(data: any): StatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roundsPlayed"] = this.roundsPlayed;
        data["totalTimePlayed"] = this.totalTimePlayed;
        data["totalFrags"] = this.totalFrags;
        data["frags"] = this.frags;
        data["flagCarrierFrags"] = this.flagCarrierFrags;
        data["deaths"] = this.deaths;
        data["environmentalDeaths"] = this.environmentalDeaths;
        data["damage"] = this.damage;
        data["flagCarrierDamage"] = this.flagCarrierDamage;
        data["damageWithFlag"] = this.damageWithFlag;
        data["flagTouches"] = this.flagTouches;
        data["pickupFlagTouches"] = this.pickupFlagTouches;
        data["assists"] = this.assists;
        data["captures"] = this.captures;
        data["pickupCaptures"] = this.pickupCaptures;
        data["flagReturns"] = this.flagReturns;
        data["powerPickups"] = this.powerPickups;
        data["killingSprees"] = this.killingSprees;
        data["rampages"] = this.rampages;
        data["dominations"] = this.dominations;
        data["unstoppables"] = this.unstoppables;
        data["godLikes"] = this.godLikes;
        data["wickedSicks"] = this.wickedSicks;
        data["doubleKills"] = this.doubleKills;
        data["multiKills"] = this.multiKills;
        data["ultraKills"] = this.ultraKills;
        data["monsterKills"] = this.monsterKills;
        return data; 
    }
}

export interface IStatsDto {
    roundsPlayed?: number;
    totalTimePlayed?: string;
    totalFrags?: number;
    frags?: number;
    flagCarrierFrags?: number;
    deaths?: number;
    environmentalDeaths?: number;
    damage?: number;
    flagCarrierDamage?: number;
    damageWithFlag?: number;
    flagTouches?: number;
    pickupFlagTouches?: number;
    assists?: number;
    captures?: number;
    pickupCaptures?: number;
    flagReturns?: number;
    powerPickups?: number;
    killingSprees?: number;
    rampages?: number;
    dominations?: number;
    unstoppables?: number;
    godLikes?: number;
    wickedSicks?: number;
    doubleKills?: number;
    multiKills?: number;
    ultraKills?: number;
    monsterKills?: number;
}

export class PlayerCaptainRecordDto implements IPlayerCaptainRecordDto {
    total?: RoundGameRecordDto | undefined;
    asCaptain?: RoundGameRecordDto | undefined;

    constructor(data?: IPlayerCaptainRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"] ? RoundGameRecordDto.fromJS(_data["total"]) : <any>undefined;
            this.asCaptain = _data["asCaptain"] ? RoundGameRecordDto.fromJS(_data["asCaptain"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PlayerCaptainRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerCaptainRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        data["asCaptain"] = this.asCaptain ? this.asCaptain.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPlayerCaptainRecordDto {
    total?: RoundGameRecordDto | undefined;
    asCaptain?: RoundGameRecordDto | undefined;
}

export class RoundGameRecordDto implements IRoundGameRecordDto {
    rounds?: RecordDto | undefined;
    matches?: RecordDto | undefined;

    constructor(data?: IRoundGameRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rounds = _data["rounds"] ? RecordDto.fromJS(_data["rounds"]) : <any>undefined;
            this.matches = _data["matches"] ? RecordDto.fromJS(_data["matches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RoundGameRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoundGameRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rounds"] = this.rounds ? this.rounds.toJSON() : <any>undefined;
        data["matches"] = this.matches ? this.matches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRoundGameRecordDto {
    rounds?: RecordDto | undefined;
    matches?: RecordDto | undefined;
}

export class RecordDto implements IRecordDto {
    wins?: number;
    losses?: number;
    ties?: number;

    constructor(data?: IRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wins = _data["wins"];
            this.losses = _data["losses"];
            this.ties = _data["ties"];
        }
    }

    static fromJS(data: any): RecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wins"] = this.wins;
        data["losses"] = this.losses;
        data["ties"] = this.ties;
        return data; 
    }
}

export interface IRecordDto {
    wins?: number;
    losses?: number;
    ties?: number;
}

export class SeasonPlayerStatsDto implements ISeasonPlayerStatsDto {
    seasonId?: number;
    seasonName?: string | undefined;
    seasonStats?: StatsDto | undefined;

    constructor(data?: ISeasonPlayerStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seasonId = _data["seasonId"];
            this.seasonName = _data["seasonName"];
            this.seasonStats = _data["seasonStats"] ? StatsDto.fromJS(_data["seasonStats"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SeasonPlayerStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonPlayerStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seasonId"] = this.seasonId;
        data["seasonName"] = this.seasonName;
        data["seasonStats"] = this.seasonStats ? this.seasonStats.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISeasonPlayerStatsDto {
    seasonId?: number;
    seasonName?: string | undefined;
    seasonStats?: StatsDto | undefined;
}

export class CreatePlayerCommand implements ICreatePlayerCommand {
    playerName?: string | undefined;
    playerAlias?: string | undefined;

    constructor(data?: ICreatePlayerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerName = _data["playerName"];
            this.playerAlias = _data["playerAlias"];
        }
    }

    static fromJS(data: any): CreatePlayerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlayerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerName"] = this.playerName;
        data["playerAlias"] = this.playerAlias;
        return data; 
    }
}

export interface ICreatePlayerCommand {
    playerName?: string | undefined;
    playerAlias?: string | undefined;
}

export class UpdatePlayerCommand implements IUpdatePlayerCommand {
    playerId?: number;
    playerName?: string | undefined;
    playerAlias?: string | undefined;

    constructor(data?: IUpdatePlayerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.playerName = _data["playerName"];
            this.playerAlias = _data["playerAlias"];
        }
    }

    static fromJS(data: any): UpdatePlayerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePlayerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["playerName"] = this.playerName;
        data["playerAlias"] = this.playerAlias;
        return data; 
    }
}

export interface IUpdatePlayerCommand {
    playerId?: number;
    playerName?: string | undefined;
    playerAlias?: string | undefined;
}

export enum RoundsOutputFileType {
    Csv = 0,
}

export class SeasonsVm implements ISeasonsVm {
    seasonList?: SeasonDto[] | undefined;

    constructor(data?: ISeasonsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["seasonList"])) {
                this.seasonList = [] as any;
                for (let item of _data["seasonList"])
                    this.seasonList!.push(SeasonDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SeasonsVm {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.seasonList)) {
            data["seasonList"] = [];
            for (let item of this.seasonList)
                data["seasonList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISeasonsVm {
    seasonList?: SeasonDto[] | undefined;
}

export class SeasonDto implements ISeasonDto {
    id?: number;
    seasonName?: string | undefined;

    constructor(data?: ISeasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.seasonName = _data["seasonName"];
        }
    }

    static fromJS(data: any): SeasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["seasonName"] = this.seasonName;
        return data; 
    }
}

export interface ISeasonDto {
    id?: number;
    seasonName?: string | undefined;
}

export class CreateSeasonCommand implements ICreateSeasonCommand {
    wadId?: number;
    seasonName?: string | undefined;
    dateStart?: Date;

    constructor(data?: ICreateSeasonCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wadId = _data["wadId"];
            this.seasonName = _data["seasonName"];
            this.dateStart = _data["dateStart"] ? new Date(_data["dateStart"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSeasonCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSeasonCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wadId"] = this.wadId;
        data["seasonName"] = this.seasonName;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreateSeasonCommand {
    wadId?: number;
    seasonName?: string | undefined;
    dateStart?: Date;
}

export class UpdateSeasonCommand implements IUpdateSeasonCommand {
    seasonId?: number;
    wadId?: number;
    seasonName?: string | undefined;
    dateStart?: Date;

    constructor(data?: IUpdateSeasonCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seasonId = _data["seasonId"];
            this.wadId = _data["wadId"];
            this.seasonName = _data["seasonName"];
            this.dateStart = _data["dateStart"] ? new Date(_data["dateStart"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateSeasonCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSeasonCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seasonId"] = this.seasonId;
        data["wadId"] = this.wadId;
        data["seasonName"] = this.seasonName;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateSeasonCommand {
    seasonId?: number;
    wadId?: number;
    seasonName?: string | undefined;
    dateStart?: Date;
}

export class SeasonSummaryVm implements ISeasonSummaryVm {
    seasonSummary?: SeasonSummaryDto | undefined;

    constructor(data?: ISeasonSummaryVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seasonSummary = _data["seasonSummary"] ? SeasonSummaryDto.fromJS(_data["seasonSummary"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SeasonSummaryVm {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonSummaryVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seasonSummary"] = this.seasonSummary ? this.seasonSummary.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISeasonSummaryVm {
    seasonSummary?: SeasonSummaryDto | undefined;
}

export class SeasonSummaryDto implements ISeasonSummaryDto {
    id?: number;
    seasonName?: string | undefined;
    winningTeam?: number | undefined;
    dateStart?: Date;
    weeks?: SeasonWeekDto[] | undefined;

    constructor(data?: ISeasonSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.seasonName = _data["seasonName"];
            this.winningTeam = _data["winningTeam"];
            this.dateStart = _data["dateStart"] ? new Date(_data["dateStart"].toString()) : <any>undefined;
            if (Array.isArray(_data["weeks"])) {
                this.weeks = [] as any;
                for (let item of _data["weeks"])
                    this.weeks!.push(SeasonWeekDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SeasonSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["seasonName"] = this.seasonName;
        data["winningTeam"] = this.winningTeam;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        if (Array.isArray(this.weeks)) {
            data["weeks"] = [];
            for (let item of this.weeks)
                data["weeks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISeasonSummaryDto {
    id?: number;
    seasonName?: string | undefined;
    winningTeam?: number | undefined;
    dateStart?: Date;
    weeks?: SeasonWeekDto[] | undefined;
}

export class SeasonWeekDto implements ISeasonWeekDto {
    idWeek?: number;
    weekNumber?: number;
    weekType?: string | undefined;
    weekStartDate?: Date;
    games?: SeasonGameDto[] | undefined;

    constructor(data?: ISeasonWeekDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idWeek = _data["idWeek"];
            this.weekNumber = _data["weekNumber"];
            this.weekType = _data["weekType"];
            this.weekStartDate = _data["weekStartDate"] ? new Date(_data["weekStartDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["games"])) {
                this.games = [] as any;
                for (let item of _data["games"])
                    this.games!.push(SeasonGameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SeasonWeekDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonWeekDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idWeek"] = this.idWeek;
        data["weekNumber"] = this.weekNumber;
        data["weekType"] = this.weekType;
        data["weekStartDate"] = this.weekStartDate ? this.weekStartDate.toISOString() : <any>undefined;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISeasonWeekDto {
    idWeek?: number;
    weekNumber?: number;
    weekType?: string | undefined;
    weekStartDate?: Date;
    games?: SeasonGameDto[] | undefined;
}

export class SeasonGameDto implements ISeasonGameDto {
    idGame?: number;
    gameType?: string | undefined;
    gameDatetime?: Date | undefined;
    teamWinnerColor?: string | undefined;
    teamForfeitColor?: string | undefined;
    redTeam?: SeasonTeamDto | undefined;
    blueTeam?: SeasonTeamDto | undefined;
    rounds?: SeasonRoundsDto[] | undefined;

    constructor(data?: ISeasonGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idGame = _data["idGame"];
            this.gameType = _data["gameType"];
            this.gameDatetime = _data["gameDatetime"] ? new Date(_data["gameDatetime"].toString()) : <any>undefined;
            this.teamWinnerColor = _data["teamWinnerColor"];
            this.teamForfeitColor = _data["teamForfeitColor"];
            this.redTeam = _data["redTeam"] ? SeasonTeamDto.fromJS(_data["redTeam"]) : <any>undefined;
            this.blueTeam = _data["blueTeam"] ? SeasonTeamDto.fromJS(_data["blueTeam"]) : <any>undefined;
            if (Array.isArray(_data["rounds"])) {
                this.rounds = [] as any;
                for (let item of _data["rounds"])
                    this.rounds!.push(SeasonRoundsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SeasonGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idGame"] = this.idGame;
        data["gameType"] = this.gameType;
        data["gameDatetime"] = this.gameDatetime ? this.gameDatetime.toISOString() : <any>undefined;
        data["teamWinnerColor"] = this.teamWinnerColor;
        data["teamForfeitColor"] = this.teamForfeitColor;
        data["redTeam"] = this.redTeam ? this.redTeam.toJSON() : <any>undefined;
        data["blueTeam"] = this.blueTeam ? this.blueTeam.toJSON() : <any>undefined;
        if (Array.isArray(this.rounds)) {
            data["rounds"] = [];
            for (let item of this.rounds)
                data["rounds"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISeasonGameDto {
    idGame?: number;
    gameType?: string | undefined;
    gameDatetime?: Date | undefined;
    teamWinnerColor?: string | undefined;
    teamForfeitColor?: string | undefined;
    redTeam?: SeasonTeamDto | undefined;
    blueTeam?: SeasonTeamDto | undefined;
    rounds?: SeasonRoundsDto[] | undefined;
}

export class SeasonTeamDto implements ISeasonTeamDto {
    idTeam?: number;
    teamName?: string | undefined;

    constructor(data?: ISeasonTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTeam = _data["idTeam"];
            this.teamName = _data["teamName"];
        }
    }

    static fromJS(data: any): SeasonTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTeam"] = this.idTeam;
        data["teamName"] = this.teamName;
        return data; 
    }
}

export interface ISeasonTeamDto {
    idTeam?: number;
    teamName?: string | undefined;
}

export class SeasonRoundsDto implements ISeasonRoundsDto {
    idRound?: number;
    roundNumber?: number | undefined;
    roundDatetime?: Date | undefined;
    roundTicsDuration?: number | undefined;
    roundWinner?: string | undefined;
    map?: SeasonMapDto | undefined;

    constructor(data?: ISeasonRoundsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idRound = _data["idRound"];
            this.roundNumber = _data["roundNumber"];
            this.roundDatetime = _data["roundDatetime"] ? new Date(_data["roundDatetime"].toString()) : <any>undefined;
            this.roundTicsDuration = _data["roundTicsDuration"];
            this.roundWinner = _data["roundWinner"];
            this.map = _data["map"] ? SeasonMapDto.fromJS(_data["map"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SeasonRoundsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonRoundsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idRound"] = this.idRound;
        data["roundNumber"] = this.roundNumber;
        data["roundDatetime"] = this.roundDatetime ? this.roundDatetime.toISOString() : <any>undefined;
        data["roundTicsDuration"] = this.roundTicsDuration;
        data["roundWinner"] = this.roundWinner;
        data["map"] = this.map ? this.map.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISeasonRoundsDto {
    idRound?: number;
    roundNumber?: number | undefined;
    roundDatetime?: Date | undefined;
    roundTicsDuration?: number | undefined;
    roundWinner?: string | undefined;
    map?: SeasonMapDto | undefined;
}

export class SeasonMapDto implements ISeasonMapDto {
    idMap?: number;
    mapPack?: string | undefined;
    mapName?: string | undefined;
    mapNumber?: number;
    file?: SeasonFileDto | undefined;

    constructor(data?: ISeasonMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idMap = _data["idMap"];
            this.mapPack = _data["mapPack"];
            this.mapName = _data["mapName"];
            this.mapNumber = _data["mapNumber"];
            this.file = _data["file"] ? SeasonFileDto.fromJS(_data["file"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SeasonMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idMap"] = this.idMap;
        data["mapPack"] = this.mapPack;
        data["mapName"] = this.mapName;
        data["mapNumber"] = this.mapNumber;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISeasonMapDto {
    idMap?: number;
    mapPack?: string | undefined;
    mapName?: string | undefined;
    mapNumber?: number;
    file?: SeasonFileDto | undefined;
}

export class SeasonFileDto implements ISeasonFileDto {
    fileName?: string | undefined;

    constructor(data?: ISeasonFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): SeasonFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        return data; 
    }
}

export interface ISeasonFileDto {
    fileName?: string | undefined;
}

export class SeasonStandingsVm implements ISeasonStandingsVm {
    seasonStandings?: SeasonStandingsDto[] | undefined;

    constructor(data?: ISeasonStandingsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["seasonStandings"])) {
                this.seasonStandings = [] as any;
                for (let item of _data["seasonStandings"])
                    this.seasonStandings!.push(SeasonStandingsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SeasonStandingsVm {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonStandingsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.seasonStandings)) {
            data["seasonStandings"] = [];
            for (let item of this.seasonStandings)
                data["seasonStandings"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISeasonStandingsVm {
    seasonStandings?: SeasonStandingsDto[] | undefined;
}

export class SeasonStandingsDto implements ISeasonStandingsDto {
    teamName?: string | undefined;
    points?: number;
    gamesPlayed?: number;
    roundsPlayed?: number;
    timePlayed?: string;
    wins?: number;
    ties?: number;
    losses?: number;
    flagCapturesFor?: number;
    flagCapturesAgainst?: number;
    flagDefenses?: number;
    frags?: number;
    damage?: number;

    constructor(data?: ISeasonStandingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teamName = _data["teamName"];
            this.points = _data["points"];
            this.gamesPlayed = _data["gamesPlayed"];
            this.roundsPlayed = _data["roundsPlayed"];
            this.timePlayed = _data["timePlayed"];
            this.wins = _data["wins"];
            this.ties = _data["ties"];
            this.losses = _data["losses"];
            this.flagCapturesFor = _data["flagCapturesFor"];
            this.flagCapturesAgainst = _data["flagCapturesAgainst"];
            this.flagDefenses = _data["flagDefenses"];
            this.frags = _data["frags"];
            this.damage = _data["damage"];
        }
    }

    static fromJS(data: any): SeasonStandingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonStandingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamName"] = this.teamName;
        data["points"] = this.points;
        data["gamesPlayed"] = this.gamesPlayed;
        data["roundsPlayed"] = this.roundsPlayed;
        data["timePlayed"] = this.timePlayed;
        data["wins"] = this.wins;
        data["ties"] = this.ties;
        data["losses"] = this.losses;
        data["flagCapturesFor"] = this.flagCapturesFor;
        data["flagCapturesAgainst"] = this.flagCapturesAgainst;
        data["flagDefenses"] = this.flagDefenses;
        data["frags"] = this.frags;
        data["damage"] = this.damage;
        return data; 
    }
}

export interface ISeasonStandingsDto {
    teamName?: string | undefined;
    points?: number;
    gamesPlayed?: number;
    roundsPlayed?: number;
    timePlayed?: string;
    wins?: number;
    ties?: number;
    losses?: number;
    flagCapturesFor?: number;
    flagCapturesAgainst?: number;
    flagDefenses?: number;
    frags?: number;
    damage?: number;
}

export class SeasonPlayersVm implements ISeasonPlayersVm {
    seasonStandings?: SeasonPlayersDto[] | undefined;

    constructor(data?: ISeasonPlayersVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["seasonStandings"])) {
                this.seasonStandings = [] as any;
                for (let item of _data["seasonStandings"])
                    this.seasonStandings!.push(SeasonPlayersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SeasonPlayersVm {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonPlayersVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.seasonStandings)) {
            data["seasonStandings"] = [];
            for (let item of this.seasonStandings)
                data["seasonStandings"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISeasonPlayersVm {
    seasonStandings?: SeasonPlayersDto[] | undefined;
}

export class SeasonPlayersDto implements ISeasonPlayersDto {
    playerName?: string | undefined;
    gamesPlayed?: number;
    roundsPlayed?: number;
    timePlayed?: string;
    points?: number;
    captures?: number;
    pickupCaptures?: number;
    assists?: number;
    flagTouches?: number;
    flagDefenses?: number;
    flagReturns?: number;
    frags?: number;
    deaths?: number;
    damage?: number;
    powerups?: number;

    constructor(data?: ISeasonPlayersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerName = _data["playerName"];
            this.gamesPlayed = _data["gamesPlayed"];
            this.roundsPlayed = _data["roundsPlayed"];
            this.timePlayed = _data["timePlayed"];
            this.points = _data["points"];
            this.captures = _data["captures"];
            this.pickupCaptures = _data["pickupCaptures"];
            this.assists = _data["assists"];
            this.flagTouches = _data["flagTouches"];
            this.flagDefenses = _data["flagDefenses"];
            this.flagReturns = _data["flagReturns"];
            this.frags = _data["frags"];
            this.deaths = _data["deaths"];
            this.damage = _data["damage"];
            this.powerups = _data["powerups"];
        }
    }

    static fromJS(data: any): SeasonPlayersDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonPlayersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerName"] = this.playerName;
        data["gamesPlayed"] = this.gamesPlayed;
        data["roundsPlayed"] = this.roundsPlayed;
        data["timePlayed"] = this.timePlayed;
        data["points"] = this.points;
        data["captures"] = this.captures;
        data["pickupCaptures"] = this.pickupCaptures;
        data["assists"] = this.assists;
        data["flagTouches"] = this.flagTouches;
        data["flagDefenses"] = this.flagDefenses;
        data["flagReturns"] = this.flagReturns;
        data["frags"] = this.frags;
        data["deaths"] = this.deaths;
        data["damage"] = this.damage;
        data["powerups"] = this.powerups;
        return data; 
    }
}

export interface ISeasonPlayersDto {
    playerName?: string | undefined;
    gamesPlayed?: number;
    roundsPlayed?: number;
    timePlayed?: string;
    points?: number;
    captures?: number;
    pickupCaptures?: number;
    assists?: number;
    flagTouches?: number;
    flagDefenses?: number;
    flagReturns?: number;
    frags?: number;
    deaths?: number;
    damage?: number;
    powerups?: number;
}

export class TeamSummaryVm implements ITeamSummaryVm {
    teamId?: number;
    seasonId?: number;
    teamName?: string | undefined;
    seasonName?: string | undefined;
    didTeamWinSeason?: boolean;
    draft?: TeamDraftDto[] | undefined;
    players?: TeamPlayerDto[] | undefined;
    gamesPlayed?: GamesPlayedDto[] | undefined;
    stats?: TeamStatsDto | undefined;

    constructor(data?: ITeamSummaryVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teamId = _data["teamId"];
            this.seasonId = _data["seasonId"];
            this.teamName = _data["teamName"];
            this.seasonName = _data["seasonName"];
            this.didTeamWinSeason = _data["didTeamWinSeason"];
            if (Array.isArray(_data["draft"])) {
                this.draft = [] as any;
                for (let item of _data["draft"])
                    this.draft!.push(TeamDraftDto.fromJS(item));
            }
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(TeamPlayerDto.fromJS(item));
            }
            if (Array.isArray(_data["gamesPlayed"])) {
                this.gamesPlayed = [] as any;
                for (let item of _data["gamesPlayed"])
                    this.gamesPlayed!.push(GamesPlayedDto.fromJS(item));
            }
            this.stats = _data["stats"] ? TeamStatsDto.fromJS(_data["stats"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TeamSummaryVm {
        data = typeof data === 'object' ? data : {};
        let result = new TeamSummaryVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamId"] = this.teamId;
        data["seasonId"] = this.seasonId;
        data["teamName"] = this.teamName;
        data["seasonName"] = this.seasonName;
        data["didTeamWinSeason"] = this.didTeamWinSeason;
        if (Array.isArray(this.draft)) {
            data["draft"] = [];
            for (let item of this.draft)
                data["draft"].push(item.toJSON());
        }
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        if (Array.isArray(this.gamesPlayed)) {
            data["gamesPlayed"] = [];
            for (let item of this.gamesPlayed)
                data["gamesPlayed"].push(item.toJSON());
        }
        data["stats"] = this.stats ? this.stats.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITeamSummaryVm {
    teamId?: number;
    seasonId?: number;
    teamName?: string | undefined;
    seasonName?: string | undefined;
    didTeamWinSeason?: boolean;
    draft?: TeamDraftDto[] | undefined;
    players?: TeamPlayerDto[] | undefined;
    gamesPlayed?: GamesPlayedDto[] | undefined;
    stats?: TeamStatsDto | undefined;
}

export class TeamDraftDto implements ITeamDraftDto {
    playerId?: number;
    playerName?: string | undefined;
    draftPosition?: string | undefined;

    constructor(data?: ITeamDraftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.playerName = _data["playerName"];
            this.draftPosition = _data["draftPosition"];
        }
    }

    static fromJS(data: any): TeamDraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamDraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["playerName"] = this.playerName;
        data["draftPosition"] = this.draftPosition;
        return data; 
    }
}

export interface ITeamDraftDto {
    playerId?: number;
    playerName?: string | undefined;
    draftPosition?: string | undefined;
}

export class TeamPlayerDto implements ITeamPlayerDto {
    playerId?: number;
    playerName?: string | undefined;

    constructor(data?: ITeamPlayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.playerName = _data["playerName"];
        }
    }

    static fromJS(data: any): TeamPlayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamPlayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["playerName"] = this.playerName;
        return data; 
    }
}

export interface ITeamPlayerDto {
    playerId?: number;
    playerName?: string | undefined;
}

export class GamesPlayedDto implements IGamesPlayedDto {
    gameId?: number;
    gameName?: string | undefined;

    constructor(data?: IGamesPlayedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameId = _data["gameId"];
            this.gameName = _data["gameName"];
        }
    }

    static fromJS(data: any): GamesPlayedDto {
        data = typeof data === 'object' ? data : {};
        let result = new GamesPlayedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameId"] = this.gameId;
        data["gameName"] = this.gameName;
        return data; 
    }
}

export interface IGamesPlayedDto {
    gameId?: number;
    gameName?: string | undefined;
}

export class TeamStatsDto implements ITeamStatsDto {
    gamesPlayed?: number;
    roundsPlayed?: number;
    timePlayed?: string;
    points?: number;
    captures?: number;
    pickupCaptures?: number;
    assists?: number;
    damageBetweenTouchAndCaptureMax?: number | undefined;
    damageBetweenTouchAndCaptureAverage?: number | undefined;
    captureTimeMin?: string;
    captureTimeMax?: string;
    captureTimeAverage?: string;
    captureHealthMin?: number | undefined;
    captureHealthMax?: number | undefined;
    captureHealthAverage?: number | undefined;
    captureGreenArmorMin?: number | undefined;
    captureGreenArmorMax?: number | undefined;
    captureGreenArmorAverage?: number | undefined;
    captureBlueArmorMin?: number | undefined;
    captureBlueArmorMax?: number | undefined;
    captureBlueArmorAverage?: number | undefined;
    capturesWithSuperPickups?: number;
    flagCarriersKilledWhileHoldingFlag?: number;
    highestKillsBeforeCapturing?: number;
    pickupCaptureTimeMin?: string;
    pickupCaptureTimeMax?: string;
    pickupCaptureTimeAverage?: string;
    flagTouches?: number;
    pickupFlagTouches?: number;
    flagDefenses?: number;
    flagReturns?: number;
    frags?: number;
    deaths?: number;
    environmentalDeaths?: number;
    environmentalFlagCarrierDeaths?: number;
    teamKills?: number;
    killingSprees?: number;
    rampages?: number;
    dominatings?: number;
    unstoppables?: number;
    godLikes?: number;
    wickedSicks?: number;
    longestSpree?: number;
    doubleKills?: number;
    multiKills?: number;
    ultraKills?: number;
    monsterKills?: number;
    highestMultiKill?: number;
    pickupHealthGained?: number;
    healthFromNonPowerups?: number;
    healthWhenTouchingFlagMin?: number | undefined;
    healthWhenTouchingFlagMax?: number | undefined;
    healthWhenTouchingFlagAverage?: number | undefined;
    greenArmorWhenTouchingFlagMin?: number | undefined;
    greenArmorWhenTouchingFlagMax?: number | undefined;
    greenArmorWhenTouchingFlagAverage?: number | undefined;
    blueArmorWhenTouchingFlagMin?: number | undefined;
    blueArmorWhenTouchingFlagMax?: number | undefined;
    blueArmorWhenTouchingFlagAverage?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureMin?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureMax?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureAverage?: number | undefined;
    damage?: number;
    damageTakenFromEnvironment?: number;
    damageTakenFromEnvironmentAsFlagCarrier?: number;
    damageToFlagCarriers?: number;
    damageDoneWithFlag?: number;
    damageToGreenArmor?: number;
    damageToBlueArmor?: number;
    powerups?: number;

    constructor(data?: ITeamStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gamesPlayed = _data["gamesPlayed"];
            this.roundsPlayed = _data["roundsPlayed"];
            this.timePlayed = _data["timePlayed"];
            this.points = _data["points"];
            this.captures = _data["captures"];
            this.pickupCaptures = _data["pickupCaptures"];
            this.assists = _data["assists"];
            this.damageBetweenTouchAndCaptureMax = _data["damageBetweenTouchAndCaptureMax"];
            this.damageBetweenTouchAndCaptureAverage = _data["damageBetweenTouchAndCaptureAverage"];
            this.captureTimeMin = _data["captureTimeMin"];
            this.captureTimeMax = _data["captureTimeMax"];
            this.captureTimeAverage = _data["captureTimeAverage"];
            this.captureHealthMin = _data["captureHealthMin"];
            this.captureHealthMax = _data["captureHealthMax"];
            this.captureHealthAverage = _data["captureHealthAverage"];
            this.captureGreenArmorMin = _data["captureGreenArmorMin"];
            this.captureGreenArmorMax = _data["captureGreenArmorMax"];
            this.captureGreenArmorAverage = _data["captureGreenArmorAverage"];
            this.captureBlueArmorMin = _data["captureBlueArmorMin"];
            this.captureBlueArmorMax = _data["captureBlueArmorMax"];
            this.captureBlueArmorAverage = _data["captureBlueArmorAverage"];
            this.capturesWithSuperPickups = _data["capturesWithSuperPickups"];
            this.flagCarriersKilledWhileHoldingFlag = _data["flagCarriersKilledWhileHoldingFlag"];
            this.highestKillsBeforeCapturing = _data["highestKillsBeforeCapturing"];
            this.pickupCaptureTimeMin = _data["pickupCaptureTimeMin"];
            this.pickupCaptureTimeMax = _data["pickupCaptureTimeMax"];
            this.pickupCaptureTimeAverage = _data["pickupCaptureTimeAverage"];
            this.flagTouches = _data["flagTouches"];
            this.pickupFlagTouches = _data["pickupFlagTouches"];
            this.flagDefenses = _data["flagDefenses"];
            this.flagReturns = _data["flagReturns"];
            this.frags = _data["frags"];
            this.deaths = _data["deaths"];
            this.environmentalDeaths = _data["environmentalDeaths"];
            this.environmentalFlagCarrierDeaths = _data["environmentalFlagCarrierDeaths"];
            this.teamKills = _data["teamKills"];
            this.killingSprees = _data["killingSprees"];
            this.rampages = _data["rampages"];
            this.dominatings = _data["dominatings"];
            this.unstoppables = _data["unstoppables"];
            this.godLikes = _data["godLikes"];
            this.wickedSicks = _data["wickedSicks"];
            this.longestSpree = _data["longestSpree"];
            this.doubleKills = _data["doubleKills"];
            this.multiKills = _data["multiKills"];
            this.ultraKills = _data["ultraKills"];
            this.monsterKills = _data["monsterKills"];
            this.highestMultiKill = _data["highestMultiKill"];
            this.pickupHealthGained = _data["pickupHealthGained"];
            this.healthFromNonPowerups = _data["healthFromNonPowerups"];
            this.healthWhenTouchingFlagMin = _data["healthWhenTouchingFlagMin"];
            this.healthWhenTouchingFlagMax = _data["healthWhenTouchingFlagMax"];
            this.healthWhenTouchingFlagAverage = _data["healthWhenTouchingFlagAverage"];
            this.greenArmorWhenTouchingFlagMin = _data["greenArmorWhenTouchingFlagMin"];
            this.greenArmorWhenTouchingFlagMax = _data["greenArmorWhenTouchingFlagMax"];
            this.greenArmorWhenTouchingFlagAverage = _data["greenArmorWhenTouchingFlagAverage"];
            this.blueArmorWhenTouchingFlagMin = _data["blueArmorWhenTouchingFlagMin"];
            this.blueArmorWhenTouchingFlagMax = _data["blueArmorWhenTouchingFlagMax"];
            this.blueArmorWhenTouchingFlagAverage = _data["blueArmorWhenTouchingFlagAverage"];
            this.healthWhenTouchingFlagThatResultsInCaptureMin = _data["healthWhenTouchingFlagThatResultsInCaptureMin"];
            this.healthWhenTouchingFlagThatResultsInCaptureMax = _data["healthWhenTouchingFlagThatResultsInCaptureMax"];
            this.healthWhenTouchingFlagThatResultsInCaptureAverage = _data["healthWhenTouchingFlagThatResultsInCaptureAverage"];
            this.damage = _data["damage"];
            this.damageTakenFromEnvironment = _data["damageTakenFromEnvironment"];
            this.damageTakenFromEnvironmentAsFlagCarrier = _data["damageTakenFromEnvironmentAsFlagCarrier"];
            this.damageToFlagCarriers = _data["damageToFlagCarriers"];
            this.damageDoneWithFlag = _data["damageDoneWithFlag"];
            this.damageToGreenArmor = _data["damageToGreenArmor"];
            this.damageToBlueArmor = _data["damageToBlueArmor"];
            this.powerups = _data["powerups"];
        }
    }

    static fromJS(data: any): TeamStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gamesPlayed"] = this.gamesPlayed;
        data["roundsPlayed"] = this.roundsPlayed;
        data["timePlayed"] = this.timePlayed;
        data["points"] = this.points;
        data["captures"] = this.captures;
        data["pickupCaptures"] = this.pickupCaptures;
        data["assists"] = this.assists;
        data["damageBetweenTouchAndCaptureMax"] = this.damageBetweenTouchAndCaptureMax;
        data["damageBetweenTouchAndCaptureAverage"] = this.damageBetweenTouchAndCaptureAverage;
        data["captureTimeMin"] = this.captureTimeMin;
        data["captureTimeMax"] = this.captureTimeMax;
        data["captureTimeAverage"] = this.captureTimeAverage;
        data["captureHealthMin"] = this.captureHealthMin;
        data["captureHealthMax"] = this.captureHealthMax;
        data["captureHealthAverage"] = this.captureHealthAverage;
        data["captureGreenArmorMin"] = this.captureGreenArmorMin;
        data["captureGreenArmorMax"] = this.captureGreenArmorMax;
        data["captureGreenArmorAverage"] = this.captureGreenArmorAverage;
        data["captureBlueArmorMin"] = this.captureBlueArmorMin;
        data["captureBlueArmorMax"] = this.captureBlueArmorMax;
        data["captureBlueArmorAverage"] = this.captureBlueArmorAverage;
        data["capturesWithSuperPickups"] = this.capturesWithSuperPickups;
        data["flagCarriersKilledWhileHoldingFlag"] = this.flagCarriersKilledWhileHoldingFlag;
        data["highestKillsBeforeCapturing"] = this.highestKillsBeforeCapturing;
        data["pickupCaptureTimeMin"] = this.pickupCaptureTimeMin;
        data["pickupCaptureTimeMax"] = this.pickupCaptureTimeMax;
        data["pickupCaptureTimeAverage"] = this.pickupCaptureTimeAverage;
        data["flagTouches"] = this.flagTouches;
        data["pickupFlagTouches"] = this.pickupFlagTouches;
        data["flagDefenses"] = this.flagDefenses;
        data["flagReturns"] = this.flagReturns;
        data["frags"] = this.frags;
        data["deaths"] = this.deaths;
        data["environmentalDeaths"] = this.environmentalDeaths;
        data["environmentalFlagCarrierDeaths"] = this.environmentalFlagCarrierDeaths;
        data["teamKills"] = this.teamKills;
        data["killingSprees"] = this.killingSprees;
        data["rampages"] = this.rampages;
        data["dominatings"] = this.dominatings;
        data["unstoppables"] = this.unstoppables;
        data["godLikes"] = this.godLikes;
        data["wickedSicks"] = this.wickedSicks;
        data["longestSpree"] = this.longestSpree;
        data["doubleKills"] = this.doubleKills;
        data["multiKills"] = this.multiKills;
        data["ultraKills"] = this.ultraKills;
        data["monsterKills"] = this.monsterKills;
        data["highestMultiKill"] = this.highestMultiKill;
        data["pickupHealthGained"] = this.pickupHealthGained;
        data["healthFromNonPowerups"] = this.healthFromNonPowerups;
        data["healthWhenTouchingFlagMin"] = this.healthWhenTouchingFlagMin;
        data["healthWhenTouchingFlagMax"] = this.healthWhenTouchingFlagMax;
        data["healthWhenTouchingFlagAverage"] = this.healthWhenTouchingFlagAverage;
        data["greenArmorWhenTouchingFlagMin"] = this.greenArmorWhenTouchingFlagMin;
        data["greenArmorWhenTouchingFlagMax"] = this.greenArmorWhenTouchingFlagMax;
        data["greenArmorWhenTouchingFlagAverage"] = this.greenArmorWhenTouchingFlagAverage;
        data["blueArmorWhenTouchingFlagMin"] = this.blueArmorWhenTouchingFlagMin;
        data["blueArmorWhenTouchingFlagMax"] = this.blueArmorWhenTouchingFlagMax;
        data["blueArmorWhenTouchingFlagAverage"] = this.blueArmorWhenTouchingFlagAverage;
        data["healthWhenTouchingFlagThatResultsInCaptureMin"] = this.healthWhenTouchingFlagThatResultsInCaptureMin;
        data["healthWhenTouchingFlagThatResultsInCaptureMax"] = this.healthWhenTouchingFlagThatResultsInCaptureMax;
        data["healthWhenTouchingFlagThatResultsInCaptureAverage"] = this.healthWhenTouchingFlagThatResultsInCaptureAverage;
        data["damage"] = this.damage;
        data["damageTakenFromEnvironment"] = this.damageTakenFromEnvironment;
        data["damageTakenFromEnvironmentAsFlagCarrier"] = this.damageTakenFromEnvironmentAsFlagCarrier;
        data["damageToFlagCarriers"] = this.damageToFlagCarriers;
        data["damageDoneWithFlag"] = this.damageDoneWithFlag;
        data["damageToGreenArmor"] = this.damageToGreenArmor;
        data["damageToBlueArmor"] = this.damageToBlueArmor;
        data["powerups"] = this.powerups;
        return data; 
    }
}

export interface ITeamStatsDto {
    gamesPlayed?: number;
    roundsPlayed?: number;
    timePlayed?: string;
    points?: number;
    captures?: number;
    pickupCaptures?: number;
    assists?: number;
    damageBetweenTouchAndCaptureMax?: number | undefined;
    damageBetweenTouchAndCaptureAverage?: number | undefined;
    captureTimeMin?: string;
    captureTimeMax?: string;
    captureTimeAverage?: string;
    captureHealthMin?: number | undefined;
    captureHealthMax?: number | undefined;
    captureHealthAverage?: number | undefined;
    captureGreenArmorMin?: number | undefined;
    captureGreenArmorMax?: number | undefined;
    captureGreenArmorAverage?: number | undefined;
    captureBlueArmorMin?: number | undefined;
    captureBlueArmorMax?: number | undefined;
    captureBlueArmorAverage?: number | undefined;
    capturesWithSuperPickups?: number;
    flagCarriersKilledWhileHoldingFlag?: number;
    highestKillsBeforeCapturing?: number;
    pickupCaptureTimeMin?: string;
    pickupCaptureTimeMax?: string;
    pickupCaptureTimeAverage?: string;
    flagTouches?: number;
    pickupFlagTouches?: number;
    flagDefenses?: number;
    flagReturns?: number;
    frags?: number;
    deaths?: number;
    environmentalDeaths?: number;
    environmentalFlagCarrierDeaths?: number;
    teamKills?: number;
    killingSprees?: number;
    rampages?: number;
    dominatings?: number;
    unstoppables?: number;
    godLikes?: number;
    wickedSicks?: number;
    longestSpree?: number;
    doubleKills?: number;
    multiKills?: number;
    ultraKills?: number;
    monsterKills?: number;
    highestMultiKill?: number;
    pickupHealthGained?: number;
    healthFromNonPowerups?: number;
    healthWhenTouchingFlagMin?: number | undefined;
    healthWhenTouchingFlagMax?: number | undefined;
    healthWhenTouchingFlagAverage?: number | undefined;
    greenArmorWhenTouchingFlagMin?: number | undefined;
    greenArmorWhenTouchingFlagMax?: number | undefined;
    greenArmorWhenTouchingFlagAverage?: number | undefined;
    blueArmorWhenTouchingFlagMin?: number | undefined;
    blueArmorWhenTouchingFlagMax?: number | undefined;
    blueArmorWhenTouchingFlagAverage?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureMin?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureMax?: number | undefined;
    healthWhenTouchingFlagThatResultsInCaptureAverage?: number | undefined;
    damage?: number;
    damageTakenFromEnvironment?: number;
    damageTakenFromEnvironmentAsFlagCarrier?: number;
    damageToFlagCarriers?: number;
    damageDoneWithFlag?: number;
    damageToGreenArmor?: number;
    damageToBlueArmor?: number;
    powerups?: number;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data; 
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: PriorityLevelDto[] | undefined;
    lists?: TodoListDto[] | undefined;

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(PriorityLevelDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodosVm {
    priorityLevels?: PriorityLevelDto[] | undefined;
    lists?: TodoListDto[] | undefined;
}

export class PriorityLevelDto implements IPriorityLevelDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IPriorityLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PriorityLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPriorityLevelDto {
    value?: number;
    name?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    items?: TodoItemDto[] | undefined;

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    items?: TodoItemDto[] | undefined;
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}